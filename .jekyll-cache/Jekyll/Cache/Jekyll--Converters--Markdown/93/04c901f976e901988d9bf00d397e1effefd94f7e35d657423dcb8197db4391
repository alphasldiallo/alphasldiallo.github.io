I"‘:<p>The Dynamic Time Warping (DTW) algorithm is one of the most used algorithms to find similarities between two time series. Its goal is to find the optimal global alignment between two time series by exploiting temporal distortions between them. DTW algorithm has been first used to match signals in speech recognition. 
However, its scope of use is wider as it can be used in Time series of two-dimensional space to model trajectories. In the case of modeling and analyzing trajectories, the DTW algorithm stands out as a good way of computing similarity between trajectories.</p>

<blockquote>
  <p>A <strong>time series</strong> is a serie of <a href="https://en.wikipedia.org/wiki/Data_point">data points</a> indexed (or listed or graphed) in time order. Most commonly, a time series &gt; is a <a href="https://en.wikipedia.org/wiki/Sequence">sequence</a> taken at successive equally spaced points in time.</p>
</blockquote>

<p>In this article, we implement the DTW algorithm for human mobility analysis to find similarities between trajectories.</p>

<p><strong>Quick reminder</strong>: A <strong>spatial trajectory</strong> is a sequence of points $ S = (‚Ä¶, s·µ¢, ‚Ä¶) $ where s·µ¢ is a tuple of longitude-latitude such as <em>s·µ¢ = (œÜ‚±º, Œª·µ¢)</em>. We denote the <strong>trajectory length</strong> by $n = <code>&#124;</code>S<code>&#124;</code>.$ We denote a <strong>subtrajectory</strong> of S as $S(i, ie) = S[i..ie]$, where $0 ‚â§ i &lt; i‚Çë ‚â§ n - 1$. The identified pair of subtrajectories is called a <strong>motif</strong>.</p>

<p>We can extract trajectories from several data sources. Some of the data sources used for capturing human mobility traces are as follows.</p>

<ul>
  <li><strong>Call Detail Records (CDRs)</strong>. Mostly accessible by network operators, CDRs have the advantage of having a huge sample size due to the ubiquity of mobile phones. These datasets offer a tower level precision and for obvious privacy reasons, these datasets are not publicly available.</li>
  <li><strong>Location-Based Social Network (LBSN)</strong>. With the increasing use of social networks, new sources of data have emerged. Social Network platforms like Facebook, Twitter or FourSquare provide geographic check-ins or geolocated publications. These data, mostly freely available, can be used as a basis to model human mobility trajectories. The main drawback of LBSN's dataset is the sparsity of the location, indeed, entries are set only when check-ins are made.</li>
  <li><strong>GPS data</strong>. Compared to the data sources previously cited, GPS data offers high spatial and temporal precision and offer a good socle to analyze full trajectories such as car movements, people movements,‚Ä¶ The drawback of GPS data is that it requires additional preprocessing due to errors when the GPS signal is noisy.</li>
</ul>

<p>To implement the DTW algorithm, we can either use an LBSN dataset or raw GPS data. In our case, we need accurate location data to draw trajectories, so we are going to use a GPS dataset. Many GPS datasets are available freely on the internet. Most of these datasets are designed from real-world data collected over a period of time. As example, we have the popular Nokia and Geolife datasets.</p>

<!--- The drawback of these datasets is their sparsity and size. The goal of this blogpost being to implement the DTW on two sub-trajectories, discovering a motif is not a priority. -->

<p>For the testing purposes, we can use a sample of the <a href="https://www.microsoft.com/en-us/download/details.aspx?id=52367">Geolife dataset</a> which contains trajectories of 182 individuals collected during 3 years by a research team of Microsoft Research Asia. It has a total of 17,621 trajectories of about 1.2 million kilometres.</p>

<p>To analyze this sample dataset, we can use the Pandas library on Python. To better understand how a trajectory similarity algorithm works, we will compute the distance manually using the DTW algorithm.</p>

<p>Requirements:</p>

<ul>
  <li>Python ‚â•3.6</li>
  <li>Pandas library</li>
  <li>Geolife sample dataset, available on this <a href="https://github.com/scikit-mobility/tutorials/raw/master/AMLD%202020/data/geolife_sample.txt.gz">link</a>.</li>
  <li>Some motivation and a big smile üòÉ</li>
</ul>

<p>Let's set up the tools and explore our dataset:</p>

<pre><code class="language-Python">import pandas as pd

# p and q represent our raw trajectories
p = "../trajectories/20081020134500.plt"
q = "../trajectories/20081023055305.plt"

df_p = pd.read_csv(p, sep=',')
df_p.head()

</code></pre>
<div align="center">
	<figure>
  <img src="/assets/img/df.png" />
  <figcaption>figure 1. result of df_p.head()</figcaption>
</figure>
</div>

<p>As you can see on figure 1, we have 4 main attributes in our dataset: lat (latitude), lng(longitude), datetime and uid(User ID). The coordinates are expressed in decimal degree using the WGS84 datum.</p>

<p>To compute the DTW, we will extract sub-trajectories of 2 users, namely u‚ÇÅ and u‚ÇÇ. The identified pair of sub-trajectories is called a motif. To find a motif with the closest distance between two sub-trajectories, a straightforward approach is to compute recursively the distance between the trajectories and to keep the trajectories that meet a particular threshold.</p>

<p>Depending on the complexity of the technique used and on the size of the dataset, this operation can quickly escalate into a lengthy process.</p>

<p>The main goal of this article is to guide through the process of finding the similarity between two trajectories and to find the warp path between two time series that is optimal.</p>

<p>In order to find the similarity between two trajectories, we need to compute a distance matrix _ <strong>dG</strong> _. It can be considered as a multidimensional array mapping every point of _ <strong>P</strong> _ with _ <strong>Q</strong> _ by their real distance. To find the distance between two geographic points, we can use the <strong>Harvesine formula</strong> illustrated in the equation below:</p>

<div align="center">
	<figure>
  <img src="/assets/img/haversine.png" />
  <figcaption>Equation 1. Haversine Formula used to calculate the great-circle distance between two points 1 and 2</figcaption>
</figure>
</div>

<p>where _ <strong>Œª‚ÇÅ</strong> <em>,</em> <strong>œï‚ÇÅ</strong> _ and _ <strong>Œª‚ÇÇ</strong> <em>,</em> <strong>œï‚ÇÇ</strong> _ are the geographical longitude and latitude in radians of the two points 1 and 2, _ <strong>ŒîŒª</strong> _ , _ <strong>Œîœï</strong> _ be their absolute differences¬π.</p>

<p>To compute the distance between u1 and u2 using DTW, we can define a function distance that computes the ground distance between two points. Then by using the principle of dynamic programming, we can go through the matrix recursively until we get the final score which will represent the DTW between our two trajectories.</p>

<p>The equation to compute the DTW P and Q (respectively u1 and u2) is the following:</p>

<div align="center">
	<figure>
  <img src="/assets/img/dtw.png" />
  <figcaption></figcaption>
</figure>
</div>

<p>Let‚Äôs implement the algorithm in Python. Even if Python is not the best programming language when it comes to object oriented programming, we will structure our code as much as we can.</p>

<p>First, we have to create a class that we are going to use. The first class should define a point, represented by longitude and latitude.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">longitude</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"Point("</span><span class="o">+</span><span class="bp">self</span><span class="p">.</span><span class="n">latitude</span><span class="o">+</span><span class="s">", "</span><span class="o">+</span><span class="bp">self</span><span class="p">.</span><span class="n">longitude</span><span class="o">+</span><span class="s">")"</span>
</code></pre></div></div>

<p>Then we will create a function that takes a point as input and returns the ground distance between the initial point (defined by self) and the point added as parameter.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
	<span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point2</span><span class="p">:</span><span class="n">Point</span><span class="p">):</span>
			<span class="n">delta_lambda</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">radians</span><span class="p">(</span><span class="n">point2</span><span class="p">.</span><span class="n">latitude</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">latitude</span><span class="p">)</span>
			<span class="n">delta_phi</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">radians</span><span class="p">(</span><span class="n">point2</span><span class="p">.</span><span class="n">longitude</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">longitude</span><span class="p">)</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delta_lambda</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delta_lambda</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">latitude</span><span class="p">))</span> \
					<span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">radians</span><span class="p">(</span><span class="n">point2</span><span class="p">.</span><span class="n">latitude</span><span class="p">))</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delta_phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delta_phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>
			<span class="n">distance</span> <span class="o">=</span> <span class="n">cls</span><span class="p">.</span><span class="n">R</span> <span class="o">*</span> <span class="n">c</span>
			<span class="k">return</span> <span class="n">distance</span>
</code></pre></div></div>

<p>Now, we have all the prerequisites to implement the code and find the distance between two trajectories. With our minimalist code, we can represent a trajectory as a list of <em><strong>Point[]</strong></em>. We can represent the ground distance between trajectories in a matrix.</p>

<p>Time complexity</p>

<p>For two trajectories N and M, the time complexity of the DTW algorithm can be presented as O(N M). Assuming that N\&gt;M, the time complexity is determined by the highest time spent to run the computation, so in this case, time complexity of the algorithm will be O(N¬≤).</p>

<p>DTW algorithm is known to have a quadratic time complexity that limits its use to only small time series data sets¬π.</p>

<p>To optimize the computational time required by the DTW algorithm, some techniques have been developed such as PruneDTW, SparseDTW, FastDTW and the MultiscaledDTW.</p>

<p>Drawbacks of DTW</p>

<p>DTW performs well for finding similarity between two trajectories if they are similar in most parts, but the main drawback of this algorithm is that it gives non-meaningful results when it comes to comparing two trajectories containing significant dissimilar portions.</p>

<p>Comparison with other similarities measures</p>

<p>By matching each point of a trajectory to another, DTW algorithm gives good results with uniformly sampled trajectories. Meanwhile, with non-uniformly sampled trajectories, DTW adds up all distances between matched pairs¬≤.</p>

<p>Algorithms available for finding similarities between trajectories can be sorted by applying a trade-off between efficiency and effectiveness. Among the most efficient method in terms of performance, the Euclidean Distance ranks amongst the best. In fact, Euclidean Distance between two time series is simply the sum of the squared distances from _n_th point to the other. The main disadvantage of using Euclidean distance for time series data is that its results are very unintuitive¬π.</p>

<p>Even though DTW gives a good balance between precision and computational time, so</p>

<p>Figure #fig_numb shows the results of DTW and DFD given 3 trajectories. S_a, S_b (uniformly sampled) and S</p>

<p>References:</p>

<ol>
  <li><a href="https://en.wikipedia.org/wiki/Haversine_formula">https://en.wikipedia.org/wiki/Haversine_formula</a></li>
  <li>Salvador, S., &amp; Chan, P. (2007). Toward accurate dynamic time warping in linear time and space. <em>Intelligent Data Analysis</em>, <em>11</em>(5), 561‚Äì580.
3.</li>
</ol>
:ET